# 处理密码加密（续）

在算法的学术领域中，如果算法的计算结果的长度是固定，会根据结果是由多少位二进制数来组成，来确定是这多少位的算法，以MD5算法为例，其计算结果是由128个二进制数组成的，所以，MD5算法是128位算法，通常，会将二进制结果转换成十六进制来表示，所以，会是32位长度的十六进制数！

常见的消息摘要算法中，MD系列的都是128位算法，SHA-1是160位算法，SHA-256是256位算法，SHA-384是384位算法，SHA-512是512位算法。

理论上来说，如果某个消息摘要算法的结果只是1位（1个二进制数），最多使用2 + 1个不同的原文，必然发生“碰撞”（即完全不同的原文对应相同的摘要），同理，如果算法的结果有2位（2个二进制数组成），最多使用4 + 1个不同的原文必然后发生碰撞，如果算法的结果有3位，最多使用8 + 1个不同的原文必然发生碰撞，而MD5是128位算法，理论上，最多需要使用2的128次方 + 1个不同的原文才能保证必然发生碰撞！

2的128次方的值是：340282366920938463463374607431768211456。

当使用MD5处理密码加密时，理论上，需要尝试340282366920938463463374607431768211456 + 1个不同的原密码，才能试出2个不同的原密码都可以登录同一个账号！由于需要尝试的次数太多，按照目前的计算机的算力，这是不可能实现的！所以，大致可以视为“找不到2个不同的原文对应相同的结果”。

通过，对于使用消息摘要算法处理密码加密的结果，如果需要破解，只能尽可能的穷举原密码（消息/原文）与加密后的密码（摘要/密文）之间的对应关系，当执行“破解”时，从记录下来的结果中进行搜索即可！例如：

| 原文    | 密码                               |
| ------- | ---------------------------------- |
| `0000`  | `4a7d1ed414474e4033ac29ccb8653d9b` |
| `0001`  | `25bbdcd06c32d477f7fa1c3e4a91b032` |
| `0002`  | `fcd04e26e900e94b9ed6dd604fed2b64` |
| ......  |                                    |
| `9999`  | `fa246d0262c3925617b0c72bb20eeb1d` |
| `aaaa`  | `74b87337454200d4d33f80c4663dc5e5` |
| `aaab`  | `4c189b020ceb022e0ecc42482802e2b8` |
| ......  |                                    |
| `zzzz`  | `02c425157ecd32f259548b33402ff6d3` |
| `00000` | `dcddb75469b4b4875094e14561e573d8` |

目前，在网络上也有许多平台提供了这种机制的“破解”！而这些平台收录的原文密文对应关系不可能特别多，假设允许使用在密码中的字符有80种，则8位长度（含以下长度）的密码有约1677万亿种，大多平台不可能收录！

所以，只要原密码足够复杂，此原密码与密文的对应关系大概率是没有被“破解”平台收录的，则不会被破解！

在编程时，为保证密码安全，应该做到：

- 要求用户使用安全强度更高的原始密码
- 在处理加密的过程中，使用循环实现多重加密
- 使用位数更长的算法
- 加盐
- 综合以上做法











